#include "rcm.h"

int read_intermezzo( uint8_t *rcm_cmd_buf ) {

    int ret = -1;
    int intermezzo_fd = 0;
    
    intermezzo_fd = open( "intermezzo.bin", O_RDONLY );
    if ( intermezzo_fd < 0 ) {
        fprintf( stderr, "Error: Couldn't open the intermezzo.bin file.\n" );
        goto exit;
    }
    
    struct stat intermezzo_stat;
    fstat( intermezzo_fd, &intermezzo_stat );
    size_t intermezzo_size = intermezzo_stat.st_size;
    if ( intermezzo_size > INTERMEZZO_LEN ) {
        fprintf( stderr, "Error: Intermezzo file exceeds max intermezzo size: %d bytes.\n", INTERMEZZO_LEN );
        goto exit;
    }

    read( intermezzo_fd, rcm_cmd_buf + RCM_CMD_BUF_INTERMEZZO_START, INTERMEZZO_LEN );
    
    ret = 0;
    
exit:
    if ( intermezzo_fd > 0) close( intermezzo_fd );

    return ret;

}

int build_rcm_cmd( uint8_t *rcm_cmd_buf, size_t rcm_cmd_buf_len, uint32_t usb_transport_add ) {

    int ret = -1;

    const uint32_t rcm_cmd_len = TO_LITTLE_ENDIAN( RCM_CMD_LEN );
    const uint32_t payload_entry = TO_LITTLE_ENDIAN( BOOTROM_PAYLOAD_ENTRY | 0x1 );
    usb_transport_add = TO_LITTLE_ENDIAN( usb_transport_add ); 

    ret = read_intermezzo( rcm_cmd_buf );
    if ( ret < 0 ) {
        goto exit;
    }
    
    memcpy( rcm_cmd_buf, (uint8_t *)&rcm_cmd_len, sizeof(uint32_t) );
    memcpy( rcm_cmd_buf + RCM_CMD_BUF_MEMCPY_RET_ADD, (uint8_t *)&payload_entry, sizeof(uint32_t) );
    memcpy( rcm_cmd_buf + RCM_CMD_BUF_TRANSPORT_ADD, (uint8_t *)&usb_transport_add, sizeof(uint32_t) );

    ret = 0;

exit:

    return ret;

}

int send_rcm_cmd( int rcm_usb, uint32_t usb_transport_add ) {

    int ret = -1;
    uint8_t *rcm_cmd_buf = 0;
    
    size_t rcm_cmd_buf_len = RCM_CMD_BUF_PAYLOAD_CONT;
    size_t padding = 0x1000 - ( rcm_cmd_buf_len % 0x1000 );
    uint32_t n_writes = ( rcm_cmd_buf_len + padding) / 0x1000;
    if ( ! ( n_writes % 2 ) ) {
        padding += 0x1000;
    }

    rcm_cmd_buf = malloc( rcm_cmd_buf_len + padding );
    if ( !rcm_cmd_buf ) {
        fprintf( stderr, "Error: Couldn't alloc memory for RCM CMD buffer\n" );
        goto exit;
    }
    memset( rcm_cmd_buf, 0x00, rcm_cmd_buf_len + padding);

    ret = build_rcm_cmd( rcm_cmd_buf, rcm_cmd_buf_len, usb_transport_add );
    if ( ret < 0 ) {
        goto exit;
    }
    
    ret = usb_send_bulk_txn( rcm_usb, RCM_EP1_OUT, rcm_cmd_buf_len + padding, rcm_cmd_buf );
    
exit:
    if (rcm_cmd_buf) free(rcm_cmd_buf);

    return ret;

}

