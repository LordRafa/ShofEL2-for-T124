#include "mini_libusb.h"

int get_usb_att(uint16_t *val, char *d_name, char *attr, int base) {

    int ret = 0;
    char filepath[256];
    char attr_buf[20];
    int attr_fd;

    snprintf(filepath, sizeof(filepath), SYSFS_DEVICE_PATH "/%s/%s", d_name, attr);
    attr_fd = open(filepath, O_RDONLY);
    if (attr_fd < 0) {
		fprintf( stderr, "Critical Error: Sysfs not avaiable." );
        return -1;
    }

    if ( !read(attr_fd, attr_buf, sizeof(attr_buf)) ) {
		fprintf( stderr, "Critical Error: Sysfs not avaiable." );
        ret = -1;
        goto exit;
    }

    *val = strtol(attr_buf, NULL, base);

exit:
    close(attr_fd);
    return ret;

}

int find_usb_path_by_vid_pid( char *path, uint16_t vid, uint16_t pid ) {

    int ret = -1;
    uint16_t d_vid, d_pid, d_bus, d_num;
    DIR *devices = opendir( SYSFS_DEVICE_PATH );
	struct dirent *entry;

	if ( !devices ) {
		fprintf( stderr, "Critical Error: Sysfs not avaiable." );
		exit( 1 );
	}

	while ( ( entry = readdir( devices ) ) ) {

        if ( !isdigit( entry->d_name[0] ) || strchr( entry->d_name, ':' ) )
			continue;
        
        if ( !get_usb_att( &d_vid, entry->d_name, "idVendor", 16 ) && ( vid == d_vid ) &&
             !get_usb_att( &d_pid, entry->d_name, "idProduct", 16 ) && ( pid == d_pid ) &&
             !get_usb_att( &d_bus, entry->d_name, "busnum", 10 ) &&
             !get_usb_att( &d_num, entry->d_name, "devnum", 10 ) ) {

            sprintf( path, "/dev/bus/usb/%03d/%03d", d_bus, d_num );
            ret = 0;
            break;

        }

    }

    closedir( devices );
    return ret;

}

int open_RCM_usb( uint16_t vid, uint16_t pid ) {

    char path[256];

    printf( "Waiting T124 to enter RCM mode. Note: root permission could be required.\n" );
    while ( find_usb_path_by_vid_pid( path, vid, pid ) ) {
        usleep(500);
    }
    printf( "K1 RCM USB Path: %s\n", path );

    return open(path, O_RDWR);

}

int send_control_txn( int fd, uint32_t bRequestType, uint32_t bRequest, uint32_t len, void *data ) {

    struct setup_data setup_data_buf;
    memset(&setup_data_buf, 0, sizeof (setup_data_buf));

    setup_data_buf.bRequestType = USB_CTRL_DEVICE_ENDPOINT_TO_HOST;
    setup_data_buf.bRequest = USB_CTRL_GET_STATUS;
    setup_data_buf.wValue = 0;
    setup_data_buf.wIndex = 0;
    setup_data_buf.wLength = len;
//    setup_data_buf.data = data;

    struct usbdevfs_urb usb_control_urb;
    memset(&usb_control_urb, 0, sizeof (usb_control_urb));

    usb_control_urb.type          = USBDEVFS_URB_TYPE_CONTROL;
    usb_control_urb.endpoint      = 0x0;
    usb_control_urb.buffer        = &setup_data_buf;
    usb_control_urb.buffer_length = sizeof(setup_data_buf);

    ioctl( fd, USBDEVFS_SUBMITURB, &usb_control_urb );
    ioctl( fd, USBDEVFS_REAPURB32, 0 );

    return 0;
}

int send_bulk_txn( int fd, uint32_t ep, uint32_t len, void *data ) {

    struct usbdevfs_bulktransfer bulk_txn;
    memset( &bulk_txn, 0, sizeof ( bulk_txn ) );
    bulk_txn.ep = ep;
    bulk_txn.len = len;
    bulk_txn.timeout = USB_BULK_TIMEOUT;
    bulk_txn.data = data;

    return ioctl( fd, USBDEVFS_BULK, &bulk_txn );

}

